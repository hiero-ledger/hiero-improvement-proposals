---
hip: 1238
title: Network Quiescence
author: Lazar Petrović <@lpetrovic05>, Kelly Greco <@poulok>, Mark Blackman <@markblackman>
working-group: Richard Bair (@rbair23)
requested-by: Hashgraph
type: Standards Track
category: Core
needs-hedera-review: Yes
hedera-review-date: 
hedera-approval-status: 
needs-hiero-approval: Yes
status: Review
created: 2025-07-11
discussions-to: https://github.com/hiero-ledger/hiero-consensus-node/pull/20069
updated: 2025-07-11
---

## Abstract

The Quiescence feature introduces a mechanism to pause event creation in Hiero networks during periods of no transaction
activity, optimizing resource usage in low-volume networks. By halting event generation when all user transactions have
reached consensus and are in fully signed blocks, Quiescence minimizes network traffic, computational overhead, and
long-term storage of event data and system transactions. This feature is particularly advantageous for private or
low-traffic Hiero networks, reducing operational and reoccurring long term storage costs. Quiescence maintains
compatibility with existing consensus mechanisms, ensuring no impact on network security, performance, or functionality.
This HIP details the quiescence conditions, mechanisms for pausing and resuming event creation, and implementation
considerations, including impacts on mirror nodes and SDKs. By prioritizing efficiency across the transaction lifecycle,
Quiescence aligns with Hiero’s commitment to sustainable, efficient distributed ledger technology.

## Motivation

Current Hiero mainnet specifications mandate continuous event creation and gossip, even in the absence of transaction
activity, to maintain consensus and network state. While robust for consistent network traffic, this approach is
inefficient for networks with periodic usage where prolonged periods without transactions are common.

The constant generation of events and blocks in such scenarios produces unnecessary data resulting in increased
bandwidth, CPU, and long-term storage usage. These inefficiencies lead to increased operational costs and unnecessary
resource utilization, misaligning with the needs of lightweight or intermittently active networks. By enabling the
network to pause event creation when no non-ancient, non-consensus transactions are pending and fully signed blocks are
achieved, the Quiescence feature addresses these shortcomings.

Quiescence provides a cost-effective mode of operation for Hiero networks with intermittent usage.

## Rationale

The rationale fleshes out the specification by describing why particular design decisions were made. It should describe
alternate designs that were considered and related work, e.g. how the feature is supported in other ecosystems. The
rationale should provide evidence of consensus within the community and discuss important objections or concerns raised
during the discussion.

## User stories

1. As a private network operator, I want the Hiero network to pause event creation when no transactions are submitted,
   so that I can reduce bandwidth and storage costs for my low-traffic Hiero network.
2. As a consensus node administrator, I want Quiescence to minimize CPU, network and memory usage during idle periods,
   so that I can run a node with lower operational expenses.
3. As a developer using Solo to test, I want the network to stop gossip and block production when inactive, so that I
   can deploy cost-effective solutions for intermittent transaction use cases.
4. As a block node or mirror node operator, I want Quiescence to reduce the flow of unnecessary event data during idle
   times, so that I can optimize storage and processing resources on my node.
5. As a network participant with scheduled transactions, I want a Hiero network to come out of Quiescence automatically
   before the target consensus timestamp, so that my scheduled transactions execute on time without manual intervention.
6. As a network participant with non-scheduled transactions, I want a Hiero network to come out of Quiescence to process
   my non-scheduled transactions.

## Specification

### Requirements

- When transactions stop being submitted to the network, the network should stop producing events in a timely manner.
  This will happen after the submitted transactions end up in a fully signed block or become stale.
- The amount of time it takes the network to stop should be close to the C2RC time of the network.
- When a transaction is submitted to a quiesced network, the network should start producing events, and this newly 
  submitted transaction should become part of a fully signed block.
- The network should stop quiescing if consensus time needs to advance for any reason, such as scheduled transactions or
  freeze.
- No existing functionality should be affected.

### Quiescence mechanisms

The quiescence feature can be broken up as follows:

- Detecting when to quiesce (quiescence conditions)
- Quiescing
- Breaking quiescence

#### Quiescence conditions

##### Rule 1: Transactions that need to reach consensus

In its simplest form, detecting when to quiesce is done by counting non-ancient non-consensus transactions. If there are
no non-ancient non-consensus transactions, there is nothing to reach consensus, so we can stop creating events.

A complication comes from block signature transactions. These transactions do not need to reach consensus. However,
they do need to be gossiped. If we want a fully signed block with all transactions, we need to create events with these
transactions and then gossip them. If we were to try to reach consensus on these signature transactions as well, we
would produce another block that would again need signatures, this way the network would never quiesce.

Additionally, we should also check if there are any pending transactions that have been submitted but are not yet part
of an event. If there are, we should not quiesce.

##### Rule 2: Fully signed blocks

In order for a block to be fully signed, it needs signatures from a majority of nodes. If a node stops creating events
after it has sent out its signature, other nodes might not be able to do the same as they might not have eligible
parents. Because of this, we should only stop creating events when a block that encompasses all user transactions
is fully signed. This can lead to a situation where more rounds reach consensus without any transactions in them, and
empty blocks end up being produced.

##### Rule 3: Target consensus timestamp (TCT)

Another exception is because some functionalities rely on consensus time advancing (i.e. freeze, scheduled
transactions). Because these mechanisms rely on consensus time advancing, they don't work if the network is quiescing.
To circumvent this problem, we need to keep track of what consensus time needs to be reached, we shall call this target
consensus timestamp (or TCT). After every handled round, the TCT might change. This can be because the previous TCT has
been reached, or because a new TCT has been set. Quiescence should not be active some duration before the TCT based on
the wall-clock. This duration shall be configurable, and will be named `tctDuration`.

#### Quiescing

Once all the conditions are met, we can quiesce. This is done by simply stopping event creation. The consensus module
will stay in this state until one of the following conditions is met:

- A transaction is submitted to the node that needs to be put into an event
- A node sends us an event with transactions that need to reach consensus
- `wallClockTime` + `tctDuration` is less than the next target consensus timestamp (TCT)

If either of these conditions is met, we will break quiescence.

#### Breaking quiescence

Breaking quiescence is simply starting event creation again. The complication comes from the tipset algorithm and other
mechanisms that prevent uncontrolled event creation. Creating an event that does not advance consensus is generally
considered a bad thing. But if only one node receives a transaction from an end user, it might not be possible to create
an event that advances consensus. This means that for quiescence, we need to introduce an exception.

The proposal is that we can have events that do not follow the same rules in the tipset and other algorithms. These
events will be used for breaking quiescence in situations like the one described above. An event used to break
quiescence will be called a QB (Quiescence Breaker). A QB will not have other-parents, only a self-parent. By having
only a self-parent, the QB can be easily identified and special rules can be applied to it. To prevent malicious nodes
from flooding the network with QBs, a QB should not be allowed to have another QB as a self-parent.

Other conditions for breaking quiescence are that the wall-clock time is nearing the next TCT, or we have received an
event with a user transaction. If this occurs, while the network is quiescing, the network should resume creating events
regularly. There is no need to create a QB in this case, since the whole network should be resuming event creation.

### Impact on Mirror Node

The only impact on Hiero Mirror node is that blocks will not flow constantly. If the network is quiesced, the mirror
node will not receive blocks until the network breaks quiescence. The mirror node will need to distinguish between
a failure and a quiesced network, since they can appear similar.

### Impact on SDK

No impacts on Heiro SDKs are expected.

## Backwards Compatibility

There are no impacts to backwards compatibility.

## Security Implications

There are no security implications of this HIP. The worst case scenario is that the network does not quiesce when it
should, which leads to increased resource usage. This is not a security issue, but rather an efficiency issue.

## How to Teach This

There is nothing to teach.

## Reference Implementation

No reference implementation exists for this HIP at the moment.

## Rejected Ideas

### TCT alternative

One of the rejected ideas was a substitute for [Rule 3](#rule-3-target-consensus-timestamp-tct). Instead of event
creation keeping track of TCT, the idea was to submit a no-op transaction to the network at this time. The main benefit
of this idea was that it would remove one of the rules for quiescence, simplifying it. However, this idea was rejected
because of the following reasons:

- It would require a new transaction type that would have no other effect than to advance consensus time.
- Each node would have to submit this transaction, which would lead to a lot of unnecessary transactions being created.
- If a node's wall-clock is off, we would break quiescence at the wrong time, which would lead to unnecessary events
  being created.

### Consensus concern

We considered having the consensus module keep track of all three quiescence conditions, but this was rejected because
they are already concerns of the execution module. Pushing these concerns into the consensus module would create several
new touchpoints between the two modules, which would complicate the design and muddle responsibilities.

## Open Issues

- How will mirror nodes detect quiescence?

## References 

N/A

## Copyright/license

This document is licensed under the Apache License, Version 2.0 —
see [LICENSE](../LICENSE) or <https://www.apache.org/licenses/LICENSE-2.0>.