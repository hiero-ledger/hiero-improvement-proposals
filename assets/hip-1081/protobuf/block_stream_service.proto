// SPDX-License-Identifier: Apache-2.0
syntax = "proto3";

package org.hiero.block.api;

import "stream/block_item.proto";

/**
 * Publish a stream of block items.
 *
 * Each request in the stream MUST contain at least one `BlockItem`.<br/>
 * Each request MAY contain more than one `BlockItem`.<br/>
 * A single request MUST NOT contain `BlockItem`s from more than one block.<br/>
 * Each request MAY contain a variable number of `BlockItem`s.<br/>
 * Each Block MUST begin with a single `BlockHeader` block item.<br/>
 * If a `BlockHeader` is present in a request, it MUST be the first `BlockItem`
 * in the `block_items` list.<br/>
 * The block node SHALL append each `BlockItem` to an internal structure
 * to reconstruct full blocks.<br/>
 * The block node MUST verify the block proof for each block before sending a
 * response message acknowledging that block.<br/>
 * Each Block MUST end with a single `BlockProof` block item.<br/>
 * If a `BlockProof` is present in a request, it MUST be the last `BlockItem`
 * in the `block_items` list.<br/>
 * The block node MUST verify each Block using the `BlockProof` to
 * ensure all data was received and processed correctly.
 */
message PublishStreamRequest {
  oneof request {
    /**
     * A stream item containing one or more `BlockItem`s.
     * <p>
     * The full stream SHALL consist of many `block_items` messages
     * followed by a single `status` message.
     */
    BlockItemSet block_items = 1;
  }
}

/**
 * An enumeration indicating why a publisher ended a stream.
 *
 * This enumeration describes the reason a block stream
 * (sent via `publishBlockStream`) was ended by the publisher.
 */
enum PublishStreamEndCode {
  /**
   * An "unset value" flag, this value SHALL NOT be used.<br/>
   * This status indicates the server software failed to set a
   * status, and SHALL be considered a software defect.
   */
  STREAM_END_UNKNOWN = 0;

  /**
   * The Publisher reached a reset point.<br/>
   * No errors occurred and the source node orderly ended the stream.
   *
   * Publishers SHOULD use this code to end a stream and restart
   * occasionally. Occasionally resetting the stream increases stability and
   * allows for routine network configuration changes.
   */
  STREAM_END_RESET = 1;

  /**
   * The delay between items was too long.<br/>
   * The destination system did not timely acknowledge a block.
   * <p>
   * The source SHALL start a new stream before the failed block.
   */
  STREAM_END_TIMEOUT = 2;

  /**
   * The publisher encountered an error.<br/>
   * The publisher encountered an internal error and must try again later.
   * <p>
   * Publishers that encounter internal logic errors, find themselves
   * "behind" the network, or otherwise detect an unexpected situation MUST
   * send this code and restart the stream before the failed block.
   */
  STREAM_END_ERROR = 3;

  /**
   * The block node is too far behind to catch up directly.<br/>
   * The block node responded to a block header with "BEHIND" and is
   * too far behind the publisher.
   * <p>
   * The block node MUST recover and "catch up" from another trustworthy
   * block node.<br/>
   * The publisher MAY stream items to a different block node.<br/>
   * The publisher MAY resume streaming to this block node later.<br/>
   * The `EndOfStream` message MUST include the earliest and latest blocks
   * currently available from the publisher.<br/>
   * The block node SHOULD attempt to "catch up" to the _latest_ block
   * available from the publisher.
   */
  STREAM_END_TOO_FAR_BEHIND = 4;
}

/**
 * A wrapper around a repeated BlockItem.<br/>
 * This message is required so that we can include ordered lists of block
 * items as `oneof` alternatives in streams.
 *
 * Each `BlockItemSet` MUST contain at least one `BlockItem`,
 * and MAY contain up to one full block.<br/>
 * A single `BlockItemSet` SHALL NOT contain block items from
 * more than one block.<br/>
 * If a `BlockHeader` is present in a `BlockItemSet`, that item
 * MUST be the first item in the list.<br/>
 * If a `BlockProof` is present in a `BlockItemSet`, that item
 * MUST be the last item in the list.
 */
message BlockItemSet {
  /**
   * An ordered list of `BlockItem`s.<br/>
   * This list supports sending block items to subscribers in batches
   * for greater channel efficiency.
   */
  repeated com.hedera.hapi.block.stream.BlockItem block_items = 1;
}

/**
 * A response to writing a block stream.
 *
 * This message is sent in response to each Block in a block stream sent
 * to a block node. The block stream is sent as a stream of messages, and each
 * message MAY be acknowledged with a message of this type.<br/>
 * Each `BlockItem` MAY be acknowledged with an `Acknowledgement`
 * response. Item acknowledgement is an OPTIONAL feature.<br/>
 * Each completed block SHALL be acknowledged with an `Acknowledgement`
 * response. Block acknowledgement is a REQUIRED feature.<br/>
 * A final response SHALL be sent with an `EndOfStream` status result after
 * the last block stream item is received, or when the receiving system
 * must end the stream for any reason.<br/>
 * If a failure is detected (which may include a block or block item that
 * fails validation) an `EndOfStream` response SHALL be sent with a
 * relevant error status.
 */
message PublishStreamResponse {
  oneof response {
    /**
     * A response sent for each block, and optionally for each item.
     */
    Acknowledgement acknowledgement = 1;

    /**
     * A response sent to request the Publisher end the current stream.
     */
    EndOfStream end_stream = 2;

    /**
     * A response sent to request the Publisher skip the current block.
     */
    SkipBlock skip_block = 3;

    /**
     * A response sent to request the Publisher resend a skipped block.
     */
    ResendBlock resend_block = 4;
  }

  /**
   * A response to acknowledge receipt and verification of a single item
   * or full block.
   */
  message Acknowledgement {
    /**
       * A response type to acknowledge a full and complete block.
       * <p>
       * All block node implementations SHOULD acknowledge each block.
       */
    BlockAcknowledgement block_ack = 1;
  }

  /**
   * Acknowledgement of a full block.<br/>
   * This message is a necessary part of the block streaming protocol.
   *
   * This response SHALL be sent after a block state proof item is
   * received and verified.<br/>
   * The block node SHALL send exactly one `BlockAcknowledgement` for
   * each successful block.<br/>
   * The `BlockAcknowledgement` response MAY be sent after sending an
   * `ItemAcknowledgement` response for the `BlockStateProof` item
   * at the end of the block, if item acknowledgement is enabled.
   */
  message BlockAcknowledgement {
    /**
     * A block number number of the acknowledged block.
     * <p>
     * A source system SHOULD verify that this value matches the block sent.
     */
    uint64 block_number = 1;

    /**
     * A hash of the virtual merkle root for the block.
     * <p>
     * This SHALL be the hash calculated by the block node for the
     * root node of the virtual merkle tree that is signed by the source
     * system to validate the block.
     */
    bytes block_root_hash = 2;

    /**
     * A flag indicating that the received block duplicates an
     * existing block.
     * <p>
     * If a source system receives acknowledgement with this flag set
     * true the source system SHOULD end the stream. The `block_number`
     * returned SHALL be the last block known and verified by the receiving
     * system, and the source system MAY resume publishing immediately
     * after that block.
     */
    bool block_already_exists = 3;
  }

  /**
   * Message indicating the Publisher should skip the current block.
   *
   * Block-Nodes SHOULD only skip a block if that block is currently being
   * received from another source.<br/>
   * Publishers MUST stop sending the current block and resume with
   * the block header for the next block, or else end the stream.<br/>
   * A Publisher that receives this message SHALL subsequently receive an
   * acknowledgement for the skipped block or SHALL receive a `ResendBlock`
   * message.<br/>
   * A Publisher asked to skip a block SHOULD NOT delay any subsequent
   * block, but should send that block as soon as it is available.<br/>
   * A Publisher MAY be asked to skip multiple blocks in succession, but
   * SHOULD interpret that as the presence of another Publisher with a
   * lower latency connection.<br/>
   * A Publisher MAY choose to end the stream and send the block to a
   * different Block-Node, rather than skip sending the block to the
   * current Block-Node.
   */
  message SkipBlock {
    /**
     * The number of the _unverified_ block to skip.
     * <p>
     * This MUST match the block number of the `BlockHeader` most recently
     * sent by the Publisher.
     */
    uint64 block_number = 1;
  }

  /**
   * Message indicating the Publisher must resend from a specified block.
   * A Publisher might resend the block, if it has that block available,
   * or it might choose to end the stream if it has already received
   * acknowledgement from a different trustworthy Block-Node.
   *
   * On receiving this message, a Publisher MUST resume sending blocks at
   * the block number indicated, or else end the stream.<br/>
   * This message SHALL only be sent following a `SkipBlock` message for a
   * block that has not been acknowledged.<br/>
   * A Block-Node SHALL NOT send a `ResendBlock` message for any block that
   * is already acknowledged.<br/>
   * A Publisher MAY choose to end the stream rather than resend the
   * the requested block.
   */
  message ResendBlock {
    /**
     * The number of the _unverified_ block to re-send.
     * <p>
     * This SHALL be the block number one greater than the last block
     * this Block-Node has successfully stored and verified.
     */
    uint64 block_number = 1;
  }

  /**
   * A message sent to end a stream.
   *
   * This response message SHALL be sent from a block node to a block
   * stream source system when a `publishBlockStream` stream ends.<br/>
   * This message SHALL be sent exactly once for each `publishBlockStream`
   * call.<br/>
   * The source system SHALL cease sending block items upon receiving
   * this response, and MAY determine the ending state of the stream from
   * the `status` enumeration and the `block_number` returned.<br/>
   * A source system SHOULD verify that the `block_number` value matches the
   * last block sent, and SHOULD resend one or more blocks if the value
   * here does not match the expected value.
   */
  message EndOfStream {
    /**
     * A response code.
     * <p>
     * This code indicates the reason the stream ended.<br/>
     * This value MUST be set to a non-default value.
     */
    PublishStreamResponseCode status = 1;

    /**
     * The number of the last completed and _verified_ block.
     * <p>
     * Nodes SHOULD only end a stream after a block state proof to avoid
     * the need to resend items.<br/>
     * If status is a failure code, the source node MUST start a new
     * stream at the beginning of the first block _following_ this number
     * (e.g. if this is 91827362983, then the new stream must start with
     * the _header_ for block 91827362984).
     */
    uint64 block_number = 2;
  }
}

/**
 * An enumeration indicating the status of this request.
 *
 * This enumeration SHALL describe the reason a block stream
 * (sent via `publishBlockStream`) ended.
 */
enum PublishStreamResponseCode {
  /**
   * An "unset value" flag, this value SHALL NOT be used.<br/>
   * This status indicates the server software failed to set a
   * status, and SHALL be considered a software defect.
   */
  STREAM_ITEMS_UNKNOWN = 0;

  /**
   * The request succeeded.<br/>
   * No errors occurred and the source node orderly ended the stream.
   */
  STREAM_ITEMS_SUCCESS = 1;

  /**
   * The delay between items was too long.<br/>
   * The source MUST start a new stream before the failed block.
   */
  STREAM_ITEMS_TIMEOUT = 2;

  /**
   * An item was received out-of-order.<br/>
   * The source MUST start a new stream before the failed block.
   */
  STREAM_ITEMS_OUT_OF_ORDER = 3;

  /**
   * A block state proof item could not be validated.<br/>
   * The source MUST start a new stream before the failed block.
   */
  STREAM_ITEMS_BAD_STATE_PROOF = 4;

  /**
   * The block node is "behind" the publisher.<br/>
   * Ths consensus node has sent a block later than this block node
   * can process. The publisher may retry by sending blocks immediately
   * following the `block_number` returned, or may end the stream and
   * try again later.
   * <p>
   * Block nodes that are "behind" SHOULD attempt to "catch up" by requesting
   * blocks from another block node or other source of recent historical
   * block stream data.
   */
  STREAM_ITEMS_BEHIND = 5;

  /**
   * The block node had an internal error and cannot continue processing.<br/>
   * The publisher may retry again later.
   */
  STREAM_ITEMS_INTERNAL_ERROR = 6;

  /**
    * The requested stream is not available.<br/>
    * The publisher may retry again later.
   */
  STREAM_ITEMS_NOT_AVAILABLE = 7;
}

/**
 * A request to stream block items from block node to a client.
 *
 * The block node SHALL respond to this request with a stream of
 * `SubscribeStreamResponse` messages.<br/>
 * The block node SHALL stream the full contents of the blocks requested.<br/>
 * The block items SHALL be streamed in order originally produced within
 * a block.<br/>
 * The blocks SHALL be streamed in ascending order by `block_number`.<br/>
 * The block node SHALL end the stream when the last requested block has
 * been sent.<br/>
 * The block node SHALL end the stream with a response code status of SUCCESS
 * when the stream is complete.<br/>
 * The client SHOULD call the `serverStatus` rpc prior to constructing this
 * request to determine the available start and end blocks.
 */
message SubscribeStreamRequest {
  /**
   * A block number to start the stream.
   * <p>
   * This SHALL be the block number of the first block returned.<br/>
   * This field MUST be less than or equal to the latest available
   * block number.
   */
  uint64 start_block_number = 1;

  /**
   * A block number to end the stream.<br/>
   * This is optional, and if not set (0), the stream will be "infinite".
   * <p>
   * This field MAY be zero (`0`) to indicate the stream SHOULD continue
   * indefinitely, streaming new blocks as each becomes available.<br/>
   * If this value is greater than zero (`0`)
   * <ul>
   *   <li>This value SHALL be the number of the last block returned.</li>
   *   <li>This field MUST NOT be less than `start_block_number`.</li>
   *   <li>This SHOULD be a block number that is immediately available
   *       from the block node.</li>
   *   <li>A block node SHALL continue to stream blocks until the last
   *       requested block is transmitted.</li>
   *   <li>A block node implementation MAY reject a request for a block
   *       that is not yet available.</li>
   *   <li>A block node implementation MAY accept future block numbers.</li>
   *   <li>Block node implementations MAY charge increased fees for such
   *       "future" streams.</li>
   * </ul>
   */
  uint64 end_block_number = 2;

  /**
   * A flag to indicate that the requested block(s) may be sent before
   * verifying each block's `BlockProof`.<br/>
   * This might be set by a client that expects to perform its own
   * verification and wishes lower latency or, potentially, lower cost.
   * <p>
   * If this value is set, then the responding Block Node MAY respond with
   * blocks that have not (yet) completed block proof verification.<br/>
   * If this is _not set_ then the Block Node MUST respond with only
   * fully verified and validated block(s).<br/>
   * If this is _set_, then a Block Node MAY stream items from
   * blocks that have not yet been verified or do not yet have
   * a block proof available.<br/>
   * The default value is _not set_.
   */
  bool allow_unverified = 3;
}

/**
 * One item in a stream of `subscribeBlockStream` responses.
 *
 * The block node SHALL respond to a `subscribeBlockStream` request with a
 * stream of `SubscribeStreamResponse` messages.<br/>
 * The block node SHALL stream the full contents of the blocks requested.<br/>
 * The block items SHALL be streamed in order originally produced within
 * a block.<br/>
 * The blocks SHALL be streamed in ascending order by `block_number`.<br/>
 * The block node SHALL end the stream when the last requested block has
 * been sent.<br/>
 * The block node SHALL end the stream with a response code status of SUCCESS
 * when the stream is complete.<br/>
 * The block node SHALL end the stream with a response code status of
 * `READ_STREAM_INVALID_START_BLOCK_NUMBER` if the start block number is
 * greater than the end block number.<br/>
 * The block node SHALL end the stream with a response code status of
 * `READ_STREAM_INSUFFICIENT_BALANCE` if insufficient balance remains to
 * complete the requested stream.
 * The block node SHALL make every reasonable effort to fulfill as much of the
 * request as available balance supports, in the event balance is not
 * sufficient to complete the request.
 */
message SubscribeStreamResponse {
  oneof response {
    /**
     * A final response item describing the terminal status of this stream.
     * <p>
     * The block node server SHALL end the stream following this message.
     */
    org.hiero.block.api.SubscribeStreamResponseCode status = 1;

    /**
     * A stream response item containing one or more `BlockItem`s.
     * <p>
     * The full stream SHALL consist of many `block_items` messages
     * followed by a single `status` message.
     */
    BlockItemSet block_items = 2;
  }
}

/**
* An enumeration indicating the status of this request.
*
* This response code SHALL be the last message in the stream of responses.
* This code SHALL represent the final status of the full request.
*/
enum SubscribeStreamResponseCode {
  /**
       * An "unset value" flag, this value SHALL NOT be used.<br/>
       * This status indicates the server software failed to set a status,
       * and SHALL be considered a software defect.
       */
  READ_STREAM_UNKNOWN = 0;

  /**
   * The requesting client account lacks sufficient HBAR to pay the
   * service fee for this request.<br/>
   * The client MAY retry the request, but MUST increase the client
   * account balance with this block node server before doing so.
   */
  READ_STREAM_INSUFFICIENT_BALANCE = 1;

  /**
   * The request succeeded.
   * <p>
   * The requested block(s) SHALL precede the status response
   * with this value.
   */
  READ_STREAM_SUCCESS = 2;

  /**
   * The requested start block number is not valid.<br/>
   * The start block number is after the end block number, less
   * than `0`, or otherwise invalid.<br/>
   * The client MAY retry this request, but MUST change the
   * `start_block_number` field to a valid start block.
   */
  READ_STREAM_INVALID_START_BLOCK_NUMBER = 3;

  /**
   * The requested end block number is not valid.<br/>
   * The end block number is greater than the highest current block
   * number, less than `0`, or otherwise invalid.<br/>
   * The client MAY retry this request, but MUST change the
   * `end_block_number` field to a valid end block.
   */
  READ_STREAM_INVALID_END_BLOCK_NUMBER = 4;

  /**
   * The requested stream is not available.<br/>
   * The client MAY retry again later.
   */
  READ_STREAM_NOT_AVAILABLE = 5;
}

/**
 * Remote procedure calls (RPCs) for the Block Node stream services.
 */
service BlockStreamService {
  /**
   * Publish a stream of blocks.
   * <p>
   * Each item in the stream MUST contain one `BlockItem`.<br/>
   * Each Block MUST begin with a single `BlockHeader` block item.<br/>
   * The block node SHALL append each `BlockItem` to an internal structure
   * to construct full blocks.<br/>
   * Each Block MUST end with a single `BlockStateProof` block item.<br/>
   * It is RECOMMENDED that the implementations verify the Block using the
   * `BlockStateProof` to validate all data was received correctly.<br/>
   * This API SHOULD, generally, be restricted based on mTLS authentication
   * to a limited set of source (i.e. consensus node) systems.
   */
  rpc publishBlockStream (stream PublishStreamRequest) returns (stream PublishStreamResponse);

  /**
   * Subscribe to a stream of blocks.
   * <p>
   * Each item in the stream SHALL contain one `BlockItem` or a
   * response code.<br/>
   * The request message MUST specify start and end block numbers
   * to return/<br/>
   * The block node SHALL stream the full contents of the blocks
   * requested.<br/>
   * The block items SHALL be streamed in order originally produced within
   * a block.<br/>
   * The blocks shall be streamed in ascending order by `block_number`.<br/>
   * The block node SHALL end the stream when the last requested block,
   * if set, has been sent.<br/>
   * A request with an end block of `0` SHALL be interpreted to indicate the
   * stream has no end. The block node SHALL continue to stream new blocks
   * as soon as each becomes available.<br/>
   * The block node SHALL end the stream with response code containing a
   * status of SUCCESS when the stream is complete.<br/>
   * The block node SHALL end the stream with a response code containing a
   * status of `READ_STREAM_INVALID_START_BLOCK_NUMBER` if the start block
   * number is greater than the end block number.<br/>
   * The block node SHALL end the stream with a response code containing a
   * status of `READ_STREAM_PAYMENT_INSUFFICIENT` if insufficient payment
   * remains to complete the requested stream.<br/>
   * The block node SHALL make every reasonable effort to fulfill as much
   * of the request as possible in the event payment is not sufficient to
   * complete the request.
   */
  rpc subscribeBlockStream(SubscribeStreamRequest) returns (stream SubscribeStreamResponse);
}